# Algorithm Study Todo List

- [ ] 1. Sliding Window Pattern
  - Uses a window that slides over data to process subsets efficiently
  - Useful for array/string problems involving subarrays or substrings
  - Time complexity often O(n)
  - LeetCode problems:
    1. 3. Longest Substring Without Repeating Characters
    2. 424. Longest Repeating Character Replacement
    3. 567. Permutation in String
    4. 76. Minimum Window Substring
    5. 239. Sliding Window Maximum

- [ ] 2. Subset
  - Generates all possible subsets of a given set
  - Often implemented using backtracking or bit manipulation
  - Time complexity usually O(2^n)
  - LeetCode problems:
    1. 78. Subsets
    2. 90. Subsets II
    3. 46. Permutations
    4. 77. Combinations
    5. 39. Combination Sum

- [ ] 3. Modified Binary Search
  - Variation of binary search for more complex scenarios
  - Used when search space is sorted or has a specific pattern
  - Time complexity O(log n)
  - LeetCode problems:
    1. 33. Search in Rotated Sorted Array
    2. 153. Find Minimum in Rotated Sorted Array
    3. 162. Find Peak Element
    4. 275. H-Index II
    5. 540. Single Element in a Sorted Array

- [ ] 4. Top K Elements
  - Finds or manipulates the k largest/smallest elements
  - Often uses heap data structure
  - Time complexity usually O(n log k)
  - LeetCode problems:
    1. 215. Kth Largest Element in an Array
    2. 347. Top K Frequent Elements
    3. 692. Top K Frequent Words
    4. 973. K Closest Points to Origin
    5. 451. Sort Characters By Frequency

- [ ] 5. Binary Tree DFS
  - Depth-First Search traversal of a binary tree
  - Includes preorder, inorder, and postorder traversals
  - Time complexity O(n)
  - LeetCode problems:
    1. 94. Binary Tree Inorder Traversal
    2. 144. Binary Tree Preorder Traversal
    3. 145. Binary Tree Postorder Traversal
    4. 104. Maximum Depth of Binary Tree
    5. 543. Diameter of Binary Tree

- [ ] 6. Topological Sort
  - Orders vertices in a directed acyclic graph
  - Often used for scheduling or dependency problems
  - Time complexity O(V + E)
  - LeetCode problems:
    1. 207. Course Schedule
    2. 210. Course Schedule II
    3. 269. Alien Dictionary
    4. 310. Minimum Height Trees
    5. 802. Find Eventual Safe States

- [ ] 7. Binary Tree BFS
  - Breadth-First Search traversal of a binary tree
  - Explores tree level by level
  - Time complexity O(n)
  - LeetCode problems:
    1. 102. Binary Tree Level Order Traversal
    2. 107. Binary Tree Level Order Traversal II
    3. 199. Binary Tree Right Side View
    4. 513. Find Bottom Left Tree Value
    5. 515. Find Largest Value in Each Tree Row

- [ ] 8. Two Pointer
  - Uses two pointers to solve array-based problems
  - Often reduces time complexity from O(n^2) to O(n)
  - LeetCode problems:
    1. 11. Container With Most Water
    2. 15. 3Sum
    3. 42. Trapping Rain Water
    4. 167. Two Sum II - Input Array Is Sorted
    5. 977. Squares of a Sorted Array

- [ ] 9. Prefix Sum
  - Precomputes cumulative sums for efficient range queries
  - Reduces time complexity for range sum queries to O(1)
  - LeetCode problems:
    1. 303. Range Sum Query - Immutable
    2. 304. Range Sum Query 2D - Immutable
    3. 560. Subarray Sum Equals K
    4. 1314. Matrix Block Sum
    5. 238. Product of Array Except Self

- [ ] 10. Fast and Slow Pattern
  - Uses two pointers moving at different speeds
  - Often used for cycle detection in linked lists
  - Time complexity O(n), space complexity O(1)
  - LeetCode problems:
    1. 141. Linked List Cycle
    2. 142. Linked List Cycle II
    3. 202. Happy Number
    4. 876. Middle of the Linked List
    5. 234. Palindrome Linked List

- [ ] 11. Linked List In-place Reversal
  - Reverses a linked list without using extra space
  - Time complexity O(n), space complexity O(1)
  - LeetCode problems:
    1. 206. Reverse Linked List
    2. 92. Reverse Linked List II
    3. 25. Reverse Nodes in k-Group
    4. 61. Rotate List
    5. 24. Swap Nodes in Pairs

- [ ] 12. Monotonic Stack
  - Stack that maintains elements in increasing/decreasing order
  - Used for problems involving next greater/smaller element
  - Time complexity often O(n)
  - LeetCode problems:
    1. 84. Largest Rectangle in Histogram
    2. 85. Maximal Rectangle
    3. 496. Next Greater Element I
    4. 739. Daily Temperatures
    5. 901. Online Stock Span

- [ ] 13. Modified Binary Search
  - Variation of binary search for more complex scenarios
  - Used when search space is sorted or has a specific pattern
  - Time complexity O(log n)
  - LeetCode problems:
    1. 33. Search in Rotated Sorted Array
    2. 153. Find Minimum in Rotated Sorted Array
    3. 162. Find Peak Element
    4. 275. H-Index II
    5. 540. Single Element in a Sorted Array

- [ ] 14. Binary Tree Traversal
  - Various ways to traverse a binary tree
  - Includes DFS (preorder, inorder, postorder) and BFS
  - Time complexity O(n)
  - LeetCode problems:
    1. 94. Binary Tree Inorder Traversal
    2. 144. Binary Tree Preorder Traversal
    3. 145. Binary Tree Postorder Traversal
    4. 102. Binary Tree Level Order Traversal
    5. 105. Construct Binary Tree from Preorder and Inorder Traversal

- [ ] 15. Depth First Search
  - Explores as far as possible along each branch before backtracking
  - Used for graph traversal and solving maze-like problems
  - Time complexity O(V + E) for graphs
  - LeetCode problems:
    1. 200. Number of Islands
    2. 133. Clone Graph
    3. 695. Max Area of Island
    4. 547. Number of Provinces
    5. 130. Surrounded Regions

- [ ] 16. Matrix Traversal
  - Techniques for efficiently traversing 2D arrays
  - Often involves DFS, BFS, or dynamic programming
  - Time complexity usually O(m * n) for m x n matrix
  - LeetCode problems:
    1. 48. Rotate Image
    2. 54. Spiral Matrix
    3. 73. Set Matrix Zeroes
    4. 79. Word Search
    5. 240. Search a 2D Matrix II
